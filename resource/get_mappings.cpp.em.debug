// generated from ros1_bridge/resource/get_mappings.cpp.em

@###############################################
@#
@# Methods for determing mappings between
@# ROS 1 and ROS 2 interfaces
@#
@# EmPy template for generating get_mappings.cpp
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - mappings (list of ros1_bridge.Mapping)
@#    Mapping between messages as well as their fields
@#  - services (list of dictionaries)
@#    Mapping between services as well as their fields
@###############################################
@
#include <map>
#include <string>
#include <iostream>

namespace ros1_bridge
{

bool
get_1to2_mapping(const std::string & ros1_type_name, std::string & ros2_type_name)
{
@[if not mappings]@
  (void)ros1_type_name;
  (void)ros2_type_name;
@[end if]@

@[for m in mappings]@
  if (ros1_type_name == "@(m.ros1_msg.package_name)/@(m.ros1_msg.message_name)")
  {
    ros2_type_name = "@(m.ros2_msg.package_name)/msg/@(m.ros2_msg.message_name)";
    return true;
  }
@[end for]@

  return false;
}


bool
get_2to1_mapping(const std::string & ros2_type_name, std::string & ros1_type_name)
{
  std::cout << "get_2to1_mapping\n";
  // If no mappings, print a message and the inputs
  @[if not mappings]@
  (void)ros1_type_name;
  (void)ros2_type_name;
  std::cout << "No mappings available.\n";
  std::cout << "ros2_type_name: " << ros2_type_name << "\n";
  @[end if]@

  // Iterate through each mapping
  bool mapping_found = false;
  std::cout << "Available mappings:\n";
  @[for m in mappings]@
  std::cout << "ROS 2 type: @(m.ros2_msg.package_name)/msg/@(m.ros2_msg.message_name)\n";
  std::cout << "ROS 1 type: @(m.ros1_msg.package_name)/@(m.ros1_msg.message_name)\n";

  // Check if the current mapping matches the ros2_type_name
  if (ros2_type_name == "@(m.ros2_msg.package_name)/msg/@(m.ros2_msg.message_name)")
  {
    ros1_type_name = "@(m.ros1_msg.package_name)/@(m.ros1_msg.message_name)";
    std::cout << "Match found!\n";
    std::cout << "ROS 2 type name: " << ros2_type_name << "\n";
    std::cout << "Mapped ROS 1 type name: " << ros1_type_name << "\n";
    mapping_found = true;
  }
  @[end for]@

  // If no mapping was found, print a message indicating so
  if (!mapping_found) {
    std::cout << "No matching mapping found for ROS 2 type: " << ros2_type_name << "\n";
  }

  return mapping_found;
}



std::multimap<std::string, std::string>
get_all_message_mappings_2to1()
{
  static std::multimap<std::string, std::string> mappings = {
@[for m in mappings]@
    {
      "@(m.ros2_msg.package_name)/msg/@(m.ros2_msg.message_name)",  // ROS 2
      "@(m.ros1_msg.package_name)/@(m.ros1_msg.message_name)"   // ROS 1
    },
@[end for]@
  };
  return mappings;
}

std::multimap<std::string, std::string>
get_all_service_mappings_2to1()
{
  static std::multimap<std::string, std::string> mappings = {
@[for s in services]@
    {
      "@(s['ros2_package'])/srv/@(s['ros2_name'])",  // ROS 2
      "@(s['ros1_package'])/@(s['ros1_name'])"   // ROS 1
    },
@[end for]@
  };
  return mappings;
}

}  // namespace ros1_bridge
